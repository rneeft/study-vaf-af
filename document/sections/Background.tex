\section{Background} \label{background}
This section describes the background of this proposal and contains information that is available but might not be known by students and readers.

What role place GUI testing in the testing spectrum? (compared with unit / integration testing)

\subsection{What is TESTAR?}
-> tool to (smart) monkey test GU -> works without scripts. -> no maintenance costs -> 4 modes (spy,generate,record, replay, view)
What is a widget -> obtaining state with widgets -> generate action set -> selection action.
% maybe copy figure 1 in here as a reference. 
The state is being checked with a test oracle (next section). TESTAR has some built-in oracles. but can also be created.

\subsection{History of GUI testing}
First we had manually testing as old as the start of development -> Capture and Replay CR -> CR becomes automated -> scripted (monkey testing).

\subsection{What is a test oracle?}
How can we know whether the SUT working as specified? A method of checking the behavior of the SUT is formally known as a \textit{test oracle} \cite{testOracles}. An example of a GUI test oracle could be that the SUT does not crash. The \textit{Assert} displayed in listing \ref{code:assert} is an example of a test oracle used by developers.

\begin{lstlisting}[language=Java, caption=Assertion, label=code:assert]
@Test
public void testAdd(){
    Calculator sut = new Calculator();

    int expected = 3;
    int actual = sut.Add(1,2);

    Assert.assertEquals(expected, actual);
}
\end{lstlisting}

oracle are checking whether the behaviour of a SUT is correct or not\cite{testOracles}. during CR method test oracle can be checking whether the same output is generated for another test run. 

for automated gui tests, the properties from widgets can be used to create test oracles. 

When having other tests, like specification tests that are testing the SUT on a different level, one could argue how granular the GUI test oracle must be. For example, let's have a look at an example test oracle for a calculator. An unit or specification test can check the SUT for calculating 1+1=2. The Test oracle for the GUI can only check whether an calculation result is shown.  

TESTAR has build-in test oracle (crash, not responding, regular expressions).  

Test oracles two types -> online which checks behavior during test execution -> offline which runs when test execution has been completed -> checks for example logs or database information.

checking state changes can be seen as offline oracle. 
 
 

\subsection{How is data retrieved from the GUI}
%% give a generic introduction about the retrieval process of the GUI
%% Windows Automation API.
%% JavaAccessBridge
%% Selenium Chromedriver
\subsubsection{Windows Automation API}
\subsubsection{JavaAccessBridge}
\subsubsection{Selenium Chromedriver}

background questions. what is now and what do we already have
- what is a model? -> Background

state is an application in state -> 

% I believe this sections belongs to the related work
- What are state models in TESTAR?
How are state models in TESTAR Now.
