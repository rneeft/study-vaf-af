\section{Background} \label{background}
    This section describes the background of this proposal and contains information that is available but might not be known by students and readers. In
    
    What role place GUI testing in the testing spectrum? (compared with unit / integration testing)

\subsection{History of GUI testing}


    First we had manually testing as old as the start of development -> Capture and Replay CR -> CR becomes automated -> scripted (monkey testing).

\subsection{What is TESTAR?}
    -> tool to (smart) monkey test GU -> works without scripts. -> no maintenance costs -> 4 modes (spy,generate,record, replay, view)
    What is a widget -> obtaining state with widgets -> generate action set -> selection action.
    % maybe copy figure 1 in here as a reference. 
    The state is being checked with a test oracle (next section). TESTAR has some built-in oracles. but can also be created.



\subsection{What is a test oracle?}
    How can we know whether the SUT working as specified? A method of checking the behavior of the SUT is formally known as a \textit{test oracle} \cite{testOracles}. An example of a GUI test oracle could be that the SUT does not crash. The \textit{Assert} displayed in listing \ref{code:assert} is an example of a test oracle used by developers.

    \begin{lstlisting}[language=Java, caption=Assertion, label=code:assert]
        @Test
        public void testAdd(){
            Calculator sut = new Calculator();
        
            int expected = 3;
            int actual = sut.Add(1,2);
        
            Assert.assertEquals(expected, actual);
        }
    \end{lstlisting}
    
    oracle are checking whether the behaviour of a SUT is correct or not\cite{testOracles}. during CR method test oracle can be checking whether the same output is generated for another test run. 
    
    for automated gui tests, the properties from widgets can be used to create test oracles. 
    
    When having other tests, like specification tests that are testing the SUT on a different level, one could argue how granular the GUI test oracle must be. For example, let's have a look at an example test oracle for a calculator. An unit or specification test can check the SUT for calculating 1+1=2. The Test oracle for the GUI can only check whether an calculation result is shown.  
    
    TESTAR has build-in test oracle (crash, not responding, regular expressions).  
    
    Test oracles two types -> online which checks behavior during test execution -> offline which runs when test execution has been completed -> checks for example logs or database information.
    
    checking state changes can be seen as offline oracle. 
     
 

\subsection{How is data retrieved}

    Generic introduction about the retrieval process of the GUI
    %% Windows Automation API.
    %% JavaAccessBridge
    %% Selenium Chromedriver
    %\subsubsection{Windows Automation API}
   %\subsubsection{JavaAccessBridge}
    %\subsubsection{Selenium Chromedriver}

    %background questions. what is now and what do we already have
    %- what is a model? -> Background
    
    %state is an application in state -> 

    % I believe this sections belongs to the related work
    %- What are state models in TESTAR?
    %How are state models in TESTAR Now.

\subsection{How is data persisted}

    TESTAR is using a database to store and retrieve state model data. Gier and Kager investigated which data storing solution would be beneficial to TESTAR \cite{GierKager}. The data solution must comply with six requirements. Generally speaking, the requirements were as follows: an open-source graph database with a straightforward query mechanic. The conclusion was that OrientDB was the best solution that met all the requirements. 
    
    OrientDB is a Multi-Model NoSQL \acrfull{dbms} that combines four models: \cite{orientDbModeling}:
   \begin{samepage}
        \begin{itemize}
            \item \hyperlink{db:key-value}{Key/Value}
            \item \hyperlink{db:document}{Document}
            \item \hyperlink{db:graph}{Graph}
            \item \hyperlink{db:object}{Object}
        \end{itemize}
    \end{samepage}

    A \hypertarget{db:key-value}{\emph{Key/Value}} is the simplest model and allows storing information (value) that is accessible with a key. Key/Values can be group into \textit{buckets} however, OrientDB support richer models in the form of document and graph elements. 

    A \hypertarget{db:document}{\emph{document}} is a schema-less set of key/value pairs. The \emph{key} allows access to the corresponding value. OrientDB allows the developer to store documents into \emph{clusters}. Relations between document are either embedded into other document or \emph{linked} to each other. Someone familiar with relational databases can view a cluster as tables, a document as the row and the key/value pairs are columns. 
    
    The \hypertarget{db:graph}{\emph{graph}} is a model consisting of \emph{Vertices} and \emph{Edges}. Vertices are the nodes in the graph, and the edge is the link between those nodes. In TESTAR terminology, a vertex represents state, and the edge is an 'action' from one state to the next. A Vertex consists of three elements: a unique identifier, a set with incoming Edges and outgoing Edges. An edge consists of four elements: a unique identifier, an incoming vertex (\emph{head}), an outgoing vertex (\emph{tail}) and a label that describes the relationship between the head and tail vertex. 

    The last model is the \hypertarget{db:object}{\emph{object}}, which supports inheritance like in the Object-Oriented programming paradigm.

    Despite being a NoSQL database, OrientDB does support SQL as a query language \cite{sql-lang} albeit that it does not support all SQL statements. The majority of developers have experience with SQL \cite{sql-stats} as a result, new developers and students can start querying the TESTAR data and start expanding its features.
    
    In addition to TESTAR, other application can also query the state model data in the OrientDB database. For example, developers en students can create external tools for a single purpose, like a state model difference application. When building external tools, the TESTAR application can be kept small and focus upon one objective: testing GUI applications. 